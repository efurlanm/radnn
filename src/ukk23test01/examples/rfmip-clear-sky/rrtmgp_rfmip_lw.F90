! *** rrtmgp_rfmip_lw.F90 ***
! This file was generated by the Notebook `rrtmgp_rfmip_lw_02.ipynb`, 
! and it is rewritten each time the Notebook is run, losing all changes 
! made to this file. To make changes to the file, you must make them 
! directly in the Notebook, and rerun it to recreate this file with the 
! changes included.

subroutine stop_on_err(error_msg)
  use iso_fortran_env, only : error_unit
  use iso_c_binding
  character(len=*), intent(in) :: error_msg

  if(error_msg /= "") then
    write (error_unit,*) trim(error_msg)
    write (error_unit,*) "Stopping."
    stop
  end if
end subroutine stop_on_err

program rrtmgp_rfmip_lw_02

use mo_rte_kind, only: wp, sp, wl, i4

use mo_optical_props, only: ty_optical_props_1scl

use mo_gas_optics_rrtmgp, only: ty_gas_optics_rrtmgp

 use mo_gas_concentrations, only: ty_gas_concs

use mo_source_functions, only: ty_source_func_lw

use mo_rte_lw, only: rte_lw

use mo_fluxes, only: ty_fluxes_broadband, ty_fluxes_flexible

use mo_load_coefficients, only: load_and_init
use mo_rfmip_io, only: read_size, read_and_block_pt, &
  read_and_block_gases_ty, unblock_and_write, unblock, &
  read_and_block_lw_bc, determine_gas_names
use mo_simple_netcdf, only: read_field, get_dim_size
use netcdf
use mod_network_rrtmgp

implicit none

character(len=132) :: rfmip_file = &
  'multiple_input4MIPs_radiation_RFMIP_UColorado-RFMIP-1-2_none.nc', &
  kdist_file = 'coefficients_lw.nc'

character(len=80) :: modelfile_tau = &
  "../../neural/data/BEST_tau-lw-18-58-58.nc", &
  modelfile_source = &
  "../../neural/data/BEST_pfrac-18-16-16.nc"

character(len=132) :: flx_file, flx_file_ref, flx_file_lbl, timing_file
integer            :: nargs, ncol, nlay, nbnd, ngpt, nexp, nblocks, &
                      block_size, forcing_index, physics_index, &
                      n_quad_angles = 1
logical            :: top_at_1
integer            :: b, icol, ilay, ibnd, igpt, count_rate, iTime1, &
                      iTime2, iTime3, ncid, ninputs, istat, igas, ret, i
character(len=5)   :: block_size_char, forcing_index_char = '1', &
                      physics_index_char = '1'
character(len=32), dimension(:), allocatable :: kdist_gas_names, &
                      rfmip_gas_names
! block_size, nlay, nblocks
real(wp), dimension(:,:,:), allocatable :: p_lay, p_lev, t_lay, t_lev
real(wp), dimension(:,:,:), target, allocatable :: flux_up, flux_dn
real(wp), dimension(:,:,:,:), target, allocatable :: gpt_flux_up, &
                      gpt_flux_dn
real(wp), dimension(:,:,:), allocatable :: rlu_ref, rld_ref, rlu_nn, &
                      rld_nn, rlu_lbl, rld_lbl, rldu_ref, rldu_nn, &
                      rldu_lbl, col_dry
! block_size, nblocks (emissivity is spectrally constant)
real(wp), dimension(:,:), allocatable :: sfc_emis, sfc_t
! nbands, block_size (spectrally-resolved emissivity)
real(wp), dimension(:,:), allocatable :: sfc_emis_spec
real(wp) :: bb_flux_up
logical :: use_rrtmgp_nn, do_gpt_flux, compare_flux, save_flux

type(ty_gas_optics_rrtmgp)  :: k_dist
type(ty_source_func_lw)     :: source
type(ty_optical_props_1scl) :: optical_props
type(ty_fluxes_flexible)   :: fluxes

! First model is for absorption, second is for Planck fraction
type(rrtmgp_network_type), dimension(:), allocatable :: neural_nets

type(ty_gas_concs), dimension(:), allocatable  :: gas_conc_array

use_rrtmgp_nn      = .false.

save_flux    = .false.

compare_flux = .false.

do_gpt_flux = .false.

print *, "Usage: "
print *, "rrtmgp_rfmip_lw_02 \"
print *, "    [block_size] \"
print *, "    [rfmip_file] \"
print *, "    [k-distribution_file] \"
print *, "    [forcing_index (1,2,3)] \"
print *, "    [physics_index (1,2)]  \"
print *, "    [input_output file]"
print *, "OR:"
print *, "rrtmgp_rfmip_lw_02 "
print *, "    [block_size] \"
print *, "    [rfmip_file] \"
print *, "    [k-distribution_file] \"
print *, "    [forcing_index] \"
print *, "    [physics_index] \"
print *, "    [NN_lw_abs_file] \"
print *, "    [NN_lw_planck_file]"

nargs = command_argument_count()
call get_command_argument(1, block_size_char)
read(block_size_char, '(i5)') block_size
if(nargs >= 2) call get_command_argument(2, rfmip_file)
if(nargs >= 3) call get_command_argument(3, kdist_file)
if(nargs >= 4) call get_command_argument(4, forcing_index_char)
if(nargs >= 5) call get_command_argument(5, physics_index_char)
if(nargs >= 6) then
  use_rrtmgp_nn = .true.
  call get_command_argument(6, modelfile_tau)
  if (nargs >= 7) then
    allocate(neural_nets(2))
    call get_command_argument(7, modelfile_source)
  else 
    allocate(neural_nets(1))
  end if
end if

call read_size(rfmip_file, ncol, nlay, nexp)

if (nexp==18) compare_flux=.true.

print *, "input file:", rfmip_file
print *, "nexp:", nexp, "ncol:", ncol, "nlay:", nlay, &
  "block_size:", block_size

if(mod(ncol*nexp, block_size) /= 0 ) &
  call stop_on_err("rrtmgp_rfmip_lw: number of columns doesn't fit &
    evenly into blocks.")
nblocks = (ncol*nexp)/block_size
print *, "Doing ",  nblocks, "blocks of size ", block_size

read(forcing_index_char, '(i4)') forcing_index
if(forcing_index < 1 .or. forcing_index > 4) &
  stop "Forcing index is invalid (must be 1, 2 ou 3)"

read(physics_index_char, '(i4)') physics_index
if(physics_index < 1 .or. physics_index > 2) &
  stop "Physics index is invalid (must be 1 ou 2)"

if(physics_index == 2) n_quad_angles = 3

if (use_rrtmgp_nn) then
  flx_file = 'output_fluxes/rlud_Efx_RTE-RRTMGP-NN-181204_rad-irf_' // &
             'r1i1p1f' // trim(forcing_index_char) // '_gn.nc'
else
  flx_file = 'output_fluxes/rlud_Efx_RTE-RRTMGP-181204_rad-irf_' // &
             'r1i1p1f' // trim(forcing_index_char) // '_gn.nc'
end if

call determine_gas_names(rfmip_file, kdist_file, forcing_index, &
  kdist_gas_names, rfmip_gas_names)

print *, "Calculation uses RFMIP gases: ", &
  (trim(kdist_gas_names(b)) // " ", b = 1, size(kdist_gas_names))

if (use_rrtmgp_nn) then
  print *, 'loading longwave absorption model from ', modelfile_tau
  call neural_nets(1) % load_netcdf(modelfile_tau)
  if (nargs >= 7) then 
    print *, 'loading Planck fraction model from ', modelfile_source
    call neural_nets(2) % load_netcdf(modelfile_source)
  end if
  ninputs = size(neural_nets(1) % layers(1) % w_transposed, 2)
  print *, "NN supports gases: ", &
    (trim(neural_nets(1) % input_names(b)) // " ", b = 3, &
    size(neural_nets(1) % input_names))
end if

call read_and_block_pt(rfmip_file, block_size, p_lay, p_lev, t_lay, &
  t_lev)
! print *, "shape t_lay, min, max", shape(t_lay), maxval(t_lay), &
!  minval(t_lay)

top_at_1 = p_lay(1, 1, 1) < p_lay(nlay, 1, 1)

call read_and_block_gases_ty(rfmip_file, block_size, kdist_gas_names, &
  rfmip_gas_names, gas_conc_array)
! do b = 1, size(gas_conc_array(1)%concs)
!  print *, "max of gas ", gas_conc_array(1)%gas_name(b), ":", &
!    maxval(gas_conc_array(1)%concs(b)%conc)
! end do
call read_and_block_lw_bc(rfmip_file, block_size, sfc_emis, sfc_t)

call load_and_init(k_dist, trim(kdist_file), gas_conc_array(1))

! print *, "min of play", minval(p_lay), &
!  "p_lay = k_dist%get_press_min()", k_dist%get_press_min()
! print *," press min max", k_dist%get_press_min(), k_dist%get_press_max()
! print *," temp min max", k_dist%get_temp_min(), k_dist%get_temp_max()

where(p_lay < k_dist%get_press_min()) &
  p_lay = k_dist%get_press_min() + spacing(k_dist%get_press_min())

if(.not. k_dist%source_is_internal()) &
  stop "rrtmgp_rfmip_lw: k-distribution file isn't LW"

nbnd = k_dist%get_nband()
ngpt = k_dist%get_ngpt()

if (top_at_1) then
  p_lev(1,:,:) = k_dist%get_press_min() + epsilon(k_dist%get_press_min())
else
  p_lev(nlay+1,:,:) = k_dist%get_press_min() + &
    epsilon(k_dist%get_press_min())
end if
! print *," shape play", shape(p_lay)
! print *, "play sfc", maxval(p_lay(nlay,:,:)), "tlay sfc", &
!  maxval(t_lay(nlay,:,:))

allocate(flux_up(nlay+1, block_size, nblocks), &
         flux_dn(nlay+1, block_size, nblocks))

! Allocate g-point fluxes if desired
if (do_gpt_flux) then
  allocate(gpt_flux_up(ngpt, nlay+1, block_size, nblocks), &
           gpt_flux_dn(ngpt, nlay+1, block_size, nblocks))
end if

allocate(sfc_emis_spec(nbnd, block_size))
!$acc enter data create(sfc_emis_spec) copyin(sfc_emis)

! OpenACC: Arrays are allocated on device inside constructor
call stop_on_err(source%alloc(block_size, nlay, k_dist))
call stop_on_err(optical_props%alloc_1scl(block_size, nlay, k_dist))

if (use_rrtmgp_nn) then
  print *, "starting clear-sky LW computations, using neural &
           networks as RRTMGP kernel"
else
  print *, "starting clear-sky LW computations, using &
           lookup-table as RRTMGP kernel"
end if
call system_clock(count_rate=count_rate)
call system_clock(iTime1)

do b = 1, nblocks
  fluxes%flux_up => flux_up(:,:,b)
  fluxes%flux_dn => flux_dn(:,:,b)    
  if (do_gpt_flux) then
    fluxes%gpt_flux_up => gpt_flux_up(:,:,:,b)
    fluxes%gpt_flux_dn => gpt_flux_dn(:,:,:,b)
  end if

do icol = 1, block_size
  do ibnd = 1, nbnd
    sfc_emis_spec(ibnd,icol) = sfc_emis(icol,b)
  end do
end do

if (use_rrtmgp_nn) then
  call stop_on_err(k_dist%gas_optics(p_lay(:,:,b),      &
                                    p_lev(:,:,b),       &
                                    t_lay(:,:,b),       &
                                    sfc_t(:,b),         &
                                    gas_conc_array(b),  &
                                    optical_props,      &
                                    source,             &
                                    tlev = t_lev(:,:,b),&
                                    neural_nets = neural_nets))
else
  call stop_on_err(k_dist%gas_optics(p_lay(:,:,b),      &
                                    p_lev(:,:,b),       &
                                    t_lay(:,:,b),       &
                                    sfc_t(:,b),         &
                                    gas_conc_array(b),  &
                                    optical_props,      &
                                    source,             &
                                    tlev = t_lev(:,:,b)))
end if

! print *, "mean of pfrac is:", mean_3d(planck_frac(:,:,:,b))
! print *, "mean of tau is:", mean_3d(optical_props%tau)
! print *, "mean of lay_source is:", mean_3d(source%lay_source)
! print *, "mean of lev_source is:", mean_3d(source%lev_source)

call system_clock(iTime2)

call stop_on_err(rte_lw(optical_props, & 
                        top_at_1, & 
                        source, & 
                        sfc_emis_spec, & 
                        fluxes, & 
                        n_gauss_angles = n_quad_angles, & 
                        use_2stream = .false.))

end do ! blocks

call system_clock(iTime3)

if (nblocks==1) then
  print *, "-----------------------------------------------------------"
  print '(a,f11.4,/,a,f11.4,/,a,f11.4,a)', &
    ' Time elapsed in gas optics:', &
    real(iTime2-iTime1) / real(count_rate), &
    ' Time elapsed in solver:    ', &
    real(iTime3-iTime2) / real(count_rate), &
    ' Time elapsed in total:     ', &
    real(iTime3-iTime1) / real(count_rate)
  print *, "-----------------------------------------------------------"
else
  print *,'Elapsed time on everything ', &
    real(iTime3-iTime1) / real(count_rate)
end if

! Also deallocates arrays on device
call optical_props%finalize()

! Also deallocates arrays on device
call source%finalize()

print*,"-----------------------------------------------------------"//&
       "-----------------------------------------------------------"

! mean of flux_down is: 103.2458
print *, "mean of flux_down is:", mean_3d(flux_dn)

print *, "mean of flux_up is:", mean_3d(flux_up)

if (save_flux) then
  print *, "Attempting to save fluxes to ", flx_file
  call unblock_and_write(trim(flx_file), 'rlu', flux_up)
  call unblock_and_write(trim(flx_file), 'rld', flux_dn)
  print *, "Fluxes saved to ", flx_file
end if 

if (compare_flux) then
  print *, "------------------------------------------------------" //&
          "------------------------------------------------------"
  print *, "-----COMPARING ERRORS (W.R.T. LINE-BY-LINE) OF NEW " //&
          "RESULTS AND RRTMGP-256  -------"
  print *, "------------------------------------------------------" //&
          "------------------------------------------------------"

  allocate(rld_ref(nlay+1, ncol, nexp))
  allocate(rlu_ref(nlay+1, ncol, nexp))
  allocate(rldu_ref(nlay+1, ncol, nexp))
  allocate(rld_nn(nlay+1, ncol, nexp))
  allocate(rlu_nn(nlay+1, ncol, nexp))
  allocate(rldu_nn(nlay+1, ncol, nexp))
  allocate(rld_lbl(nlay+1, ncol, nexp))
  allocate(rlu_lbl(nlay+1, ncol, nexp))
  allocate(rldu_lbl(nlay+1, ncol, nexp))

  flx_file_ref = 'output_fluxes/rlud_Efx_RTE-RRTMGP-181204_rad-' //&
                 'irf_r1i1p1f1_gn_REF-DP.nc'
  flx_file_lbl = 'output_fluxes/rlud_Efx_LBLRTM-12-8_rad-irf_' //&
                 'r1i1p1f1_gn.nc'

  call unblock(flux_up, rlu_nn)
  call unblock(flux_dn, rld_nn)
  rldu_nn = rld_nn - rlu_nn

  if(nf90_open(trim(flx_file_ref), NF90_NOWRITE, ncid) /= NF90_NOERR) &
    call stop_on_err("read_and_block_gases_ty: can't find file " //&
                     trim(flx_file_ref))
  rlu_ref = read_field(ncid, "rlu", nlay+1, ncol, nexp)
  rld_ref = read_field(ncid, "rld", nlay+1, ncol, nexp)
  rldu_ref = rld_ref - rlu_ref

  if(nf90_open(trim(flx_file_lbl), NF90_NOWRITE, ncid) /= NF90_NOERR) &
    call stop_on_err("read_and_block_gases_ty: can't find file " //&
                     trim(flx_file_lbl))
  rlu_lbl = read_field(ncid, "rlu", nlay+1, ncol, nexp)
  rld_lbl = read_field(ncid, "rld", nlay+1, ncol, nexp)
  rldu_lbl = rld_lbl - rlu_lbl

print *, "------------- UPWELLING --------------"

print *, "MAE in upwelling fluxes of new result and RRTMGP, " //&
         "present-day:", &
         mae(reshape(rlu_lbl(:,:,1), shape = [1*ncol*(nlay+1)]), &
         reshape(rlu_nn(:,:,1), shape = [1*ncol*(nlay+1)])), &
         mae(reshape(rlu_lbl(:,:,1), shape = [1*ncol*(nlay+1)]), &
         reshape(rlu_ref(:,:,1), shape = [1*ncol*(nlay+1)]))

print *, "MAE in upwelling fluxes of new result and RRTMGP, " //&
         "future:", &
         mae(reshape(rlu_lbl(:,:,4), shape = [1*ncol*(nlay+1)]), &
         reshape(rlu_nn(:,:,4), shape = [1*ncol*(nlay+1)])), &
         mae(reshape(rlu_lbl(:,:,4), shape = [1*ncol*(nlay+1)]), &
         reshape(rlu_ref(:,:,4), shape = [1*ncol*(nlay+1)]))

! bias in upwelling flux of new result and RRTMGP,
! present-day, top-of-atm.
print *, "bias in upwelling flux of new result and RRTMGP, " //&
         "present-day, top-of-atm.:", &
         bias(reshape(rlu_lbl(1,:,1), shape = [1*ncol]), &
         reshape(rlu_nn(1,:,1), shape = [1*ncol])), &
         bias(reshape(rlu_lbl(1,:,1), shape = [1*ncol]), &
         reshape(rlu_ref(1,:,1), shape = [1*ncol]))

! bias in upwelling flux of new result and RRTMGP,
! future, top-of-atm.
print *, "bias in upwelling flux of new result and RRTMGP, " //&
         "future, top-of-atm.:", &
         bias(reshape(rlu_lbl(1,:,4), shape = [1*ncol]), &
         reshape(rlu_nn(1,:,4), shape = [1*ncol])), &
         bias(reshape(rlu_lbl(1,:,4), shape = [1*ncol]), &
         reshape(rlu_ref(1,:,4), shape = [1*ncol]))

! bias in upwelling flux of new result and RRTMGP,
! ALL EXPS, top-of-atm.
print *, "bias in upwelling flux of new result and RRTMGP, " //&
         "ALL EXPS, top-of-atm.:", &
         bias(reshape(rlu_lbl(1,:,:), shape = [nexp*ncol]), &
         reshape(rlu_nn(1,:,:), shape = [nexp*ncol])), &
         bias(reshape(rlu_lbl(1,:,:), shape = [nexp*ncol]), &
         reshape(rlu_ref(1,:,:), shape = [nexp*ncol]))

print *, "-------------- DOWNWELLING --------------"

print *, "MAE in downwelling fluxes of new result and RRTMGP, " //&
         "present-day:", &
         mae(reshape(rld_lbl(:,:,1), shape = [1*ncol*(nlay+1)]), &
         reshape(rld_nn(:,:,1), shape = [1*ncol*(nlay+1)])), &
         mae(reshape(rld_lbl(:,:,1), shape = [1*ncol*(nlay+1)]), &
         reshape(rld_ref(:,:,1), shape = [1*ncol*(nlay+1)]))

! print *, "MAE in downwelling fluxes of new result and RRTMGP, " //&
!          "future:", &
!          mae(reshape(rld_lbl(:,:,4), shape = [1*ncol*(nlay+1)]), &
!          reshape(rld_nn(:,:,4), shape = [1*ncol*(nlay+1)])), &
!          mae(reshape(rld_lbl(:,:,4), shape = [1*ncol*(nlay+1)]), &
!          reshape(rld_ref(:,:,4), shape = [1*ncol*(nlay+1)]))

print *, "-------------- NET FLUX --------------"

print *, "Max-vertical-error in net fluxes of new result and RRTMGP, " //&
         "pres.day:", &
         maxval(abs(rldu_lbl(:,:,1) - rldu_nn(:,:,1))), &
         maxval(abs(rldu_lbl(:,:,1) - rldu_ref(:,:,1)))

! print *, "Max-vertical-error in net fluxes of new result and RRTMGP, " //&
!          "future:", &
!          maxval(abs(rldu_lbl(:,:,4) - rldu_nn(:,:,4))), &
!          maxval(abs(rldu_lbl(:,:,4) - rldu_ref(:,:,4)))

print *, "Max-vertical-error in net fluxes of new result and RRTMGP, " //&
         "future-all:", &
         maxval(abs(rldu_lbl(:,:,17) - rldu_nn(:,:,17))), &
         maxval(abs(rldu_lbl(:,:,17) - rldu_ref(:,:,17)))

! Print header
print *, "---------"
! Print MAE for present-day net fluxes
print *, "MAE in net fluxes of new result and RRTMGP, present-day: ", &
        mae(reshape(rldu_lbl(:,:,1), shape = [1*ncol*(nlay+1)]), &
        reshape(rldu_nn(:,:,1), shape = [1*ncol*(nlay+1)])), &
        mae(reshape(rldu_lbl(:,:,1), shape = [1*ncol*(nlay+1)]), &
        reshape(rldu_ref(:,:,1), shape = [1*ncol*(nlay+1)]))
! Print MAE for future net fluxes
!print *, "#MAE in net fluxes of new result and RRTMGP, future: ", &
!        mae(reshape(rldu_lbl(:,:,4), shape = [1*ncol*(nlay+1)]), &
!        reshape(rldu_nn(:,:,4), shape = [1*ncol*(nlay+1)])), &
!        mae(reshape(rldu_lbl(:,:,4), shape = [1*ncol*(nlay+1)]), &
!        reshape(rldu_ref(:,:,4), shape = [1*ncol*(nlay+1)]))
! Print MAE for future-all net fluxes
print *, "MAE in net fluxes of new result and RRTMGP, future-all: ", &
        mae(reshape(rldu_lbl(:,:,17), shape = [1*ncol*(nlay+1)]), &
        reshape(rldu_nn(:,:,17), shape = [1*ncol*(nlay+1)])), &
        mae(reshape(rldu_lbl(:,:,17), shape = [1*ncol*(nlay+1)]), &
        reshape(rldu_ref(:,:,17), shape = [1*ncol*(nlay+1)]))
! Print MAE for all experiments
print *, "MAE in net fluxes of new result and RRTMGP, ALL EXPS: ", &
        mae(reshape(rldu_lbl(:,:,:), shape = [nexp*ncol*(nlay+1)]), &
        reshape(rldu_nn(:,:,:), shape = [nexp*ncol*(nlay+1)])), &
        mae(reshape(rldu_lbl(:,:,:), shape = [nexp*ncol*(nlay+1)]), &
        reshape(rldu_ref(:,:,:), shape = [nexp*ncol*(nlay+1)]))

print *, "---------"

! Print RMSE for present-day net fluxes
!print *, "#RMSE in net fluxes of new result and RRTMGP, present-day: ", &
!        rmse(reshape(rldu_lbl(:,:,1), shape = [1*ncol*(nlay+1)]), &
!        reshape(rldu_nn(:,:,1), shape = [1*ncol*(nlay+1)])), &
!        rmse(reshape(rldu_lbl(:,:,1), shape = [1*ncol*(nlay+1)]), &
!        reshape(rldu_ref(:,:,1), shape = [1*ncol*(nlay+1)]))

! Print RMSE for present-day net fluxes, surface
!print *, "RMSE in net fluxes of new result and RRTMGP, present-day, SURFACE: ", &
!        rmse(reshape(rldu_lbl(nlay+1,:,1), shape = [1*ncol]), &
!        reshape(rldu_nn(nlay+1,:,1), shape = [1*ncol])), &
!        rmse(reshape(rldu_lbl(nlay+1,:,1), shape = [1*ncol]), &
!        reshape(rldu_ref(nlay+1,:,1), shape = [1*ncol]))

! Print RMSE for present-day net fluxes, TOA
!print *, "#RMSE in net fluxes of new result and RRTMGP, present-day, TOA: ", &
!        rmse(reshape(rldu_lbl(1,:,1), shape = [1*ncol]), &
!        reshape(rldu_nn(1,:,1), shape = [1*ncol])), &
!        rmse(reshape(rldu_lbl(1,:,1), shape = [1*ncol]), &
!        reshape(rldu_ref(1,:,1), shape = [1*ncol]))

! Print RMSE for future-all net fluxes, surface
!print *, "#RMSE in net fluxes of new result and RRTMGP, future-all, SURFACE: ", &
!        rmse(reshape(rldu_lbl(nlay+1,:,17), shape = [1*ncol]), &
!        reshape(rldu_nn(nlay+1,:,17), shape = [1*ncol])), &
!        rmse(reshape(rldu_lbl(nlay+1,:,17), shape = [1*ncol]), &
!        reshape(rldu_ref(nlay+1,:,17), shape = [1*ncol]))

! Print RMSE for pre-industrial net fluxes, surface
!print *, "#RMSE in net fluxes of new result and RRTMGP, pre-industrial, SURFACE: ", &
!        rmse(reshape(rldu_lbl(nlay+1,:,2), shape = [1*ncol]), &
!        reshape(rldu_nn(nlay+1,:,2), shape = [1*ncol])), &
!        rmse(reshape(rldu_lbl(nlay+1,:,2), shape = [1*ncol]), &
!        reshape(rldu_ref(nlay+1,:,2), shape = [1*ncol]))

print *, "---------"
! Bias in net fluxes of new result and RRTMGP, present-day
!print *, "#bias in net fluxes of new result and RRTMGP, ", &
!        "present-day: ", &
!        bias(reshape(rldu_lbl(:,:,1), shape = [1*ncol*(nlay+1)]), &
!        reshape(rldu_nn(:,:,1), shape = [1*ncol*(nlay+1)])), &
!        bias(reshape(rldu_lbl(:,:,1), shape = [1*ncol*(nlay+1)]), &
!        reshape(rldu_ref(:,:,1), shape = [1*ncol*(nlay+1)]))
! Bias in net fluxes of new result and RRTMGP, SURFACE
!print *, "#bias in net fluxes of new result and RRTMGP, ", &
!        "present-day, SURFACE: ", &
!        bias(reshape(rldu_lbl(nlay+1,:,1), shape = [1*ncol]), &
!        reshape(rldu_nn(nlay+1,:,1), shape = [1*ncol])), &
!        bias(reshape(rldu_lbl(nlay+1,:,1), shape = [1*ncol]), &
!        reshape(rldu_ref(nlay+1,:,1), shape = [1*ncol]))
! Bias in net fluxes of new result and RRTMGP, future
!print *, "#bias in net fluxes of new result and RRTMGP, ", &
!        "future: ", &
!        bias(reshape(rldu_lbl(:,:,4), shape = [1*ncol*(nlay+1)]), &
!        reshape(rldu_nn(:,:,4), shape = [1*ncol*(nlay+1)])), &
!        bias(reshape(rldu_lbl(:,:,4), shape = [1*ncol*(nlay+1)]), &
!        reshape(rldu_ref(:,:,4), shape = [1*ncol*(nlay+1)]))
! Bias in net fluxes of new result and RRTMGP, future-all
!print *, "#bias in net fluxes of new result and RRTMGP, ", &
!        "future-all: ", &
!        bias(reshape(rldu_lbl(:,:,17), shape = [1*ncol*(nlay+1)]), &
!        reshape(rldu_nn(:,:,17), shape = [1*ncol*(nlay+1)])), &
!        bias(reshape(rldu_lbl(:,:,17), shape = [1*ncol*(nlay+1)]), &
!        reshape(rldu_ref(:,:,17), shape = [1*ncol*(nlay+1)]))
! Bias in net fluxes of new result and RRTMGP, SURFACE, future-all
print *, "bias in net fluxes of new result and RRTMGP, ", &
        "future-all, SURFACE: ", &
        bias(reshape(rldu_lbl(nlay+1,:,17), shape = [1*ncol]), &
        reshape(rldu_nn(nlay+1,:,17), shape = [1*ncol])), &
        bias(reshape(rldu_lbl(nlay+1,:,17), shape = [1*ncol]), &
        reshape(rldu_ref(nlay+1,:,17), shape = [1*ncol]))
print *, "---------"
! Radiative forcing error at surface, pre-industrial N2O to present-day
print *, "radiative forcing error at surface, ", &
        "pre-industrial N2O to present-day: ", &
        mean(rld_lbl(nlay+1,:,11) - rld_lbl(nlay+1,:,1)) - &
        mean(rld_nn(nlay+1,:,11) - rld_nn(nlay+1,:,1)), &
        mean(rld_lbl(nlay+1,:,11) - rld_lbl(nlay+1,:,1)) - &
        mean(rld_ref(nlay+1,:,11) - rld_ref(nlay+1,:,1))
! Radiative forcing error at TOA, pre-industrial N2O to present-day
print *, "radiative forcing error at TOA, ", &
        "pre-industrial N2O to present-day: ", &
        mean(rlu_lbl(1,:,11) - rlu_lbl(1,:,1)) - &
        mean(rlu_nn(1,:,11) - rlu_nn(1,:,1)), &
        mean(rlu_lbl(1,:,11) - rlu_lbl(1,:,1)) - &
        mean(rlu_ref(1,:,11) - rlu_ref(1,:,1))
! MAE in upwelling fluxes of new result w.r.t RRTMGP, present-day
!print *, "#MAE in upwelling fluxes of new result w.r.t RRTMGP, ", &
!        "present-day: ", &
!        mae(reshape(rlu_ref(:,:,1), shape = [1*ncol*(nlay+1)]), &
!        reshape(rlu_nn(:,:,1), shape = [1*ncol*(nlay+1)]))
! MAE in upwelling fluxes of new result w.r.t RRTMGP, present-day, SFC
!print *, "#MAE in upwelling fluxes of new result w.r.t RRTMGP, ", &
!        "present-day, SFC: ", &
!        mae(reshape(rlu_ref(nlay+1,:,1), shape = [1*ncol]), &
!        reshape(rlu_nn(nlay+1,:,1), shape = [1*ncol]))
! MAE in downwelling fluxes of new result w.r.t RRTMGP, present-day, SFC
!print *, "#MAE in downwelling fluxes of new result w.r.t RRTMGP, ", &
!        "present-day, SFC: ", &
!        mae(reshape(rld_ref(nlay+1,:,1), shape = [1*ncol]), &
!        reshape(rld_nn(nlay+1,:,1), shape = [1*ncol]))
! MAE in downwelling fluxes of new result w.r.t RRTMGP, present-day
!print *, "#MAE in downwelling fluxes of new result w.r.t RRTMGP, ", &
!        "present-day: ", &
!        mae(reshape(rld_ref(:,:,1), shape = [1*ncol*(nlay+1)]), &
!        reshape(rld_nn(:,:,1), shape = [1*ncol*(nlay+1)]))

print *, "---------"

! Print MAE for net fluxes with respect to RRTMGP
print *, "MAE in net flux w.r.t RRTMGP ", &
        mae(reshape(rldu_ref(:,:,:), shape = [nexp*ncol*(nlay+1)]), &
        reshape(rldu_nn(:,:,:), shape = [nexp*ncol*(nlay+1)]))

! Print max difference in downward flux with respect to RRTMGP
print *, "Max-diff in d.w. flux w.r.t RRTMGP ", &
        maxval(abs(rld_ref(:,:,:)-rld_nn(:,:,:)))

! Print max difference in upward flux with respect to RRTMGP
print *, "Max-diff in u.w. flux w.r.t RRTMGP ", &
        maxval(abs(rlu_ref(:,:,:)-rlu_nn(:,:,:)))

! Print max difference in net flux with respect to RRTMGP
print *, "Max-diff in net flux w.r.t RRTMGP ", &
        maxval(abs(rldu_ref(:,:,:)-rldu_nn(:,:,:)))

! Deallocate arrays
deallocate(rld_ref, rlu_ref, rld_nn, rlu_nn, rld_lbl, rlu_lbl, &
           rldu_ref, rldu_nn, rldu_lbl)

end if

deallocate(flux_up, flux_dn)
print *, "SUCCESS!"

contains

function rmse(x1,x2) result(res)
  implicit none 
  real(wp), dimension(:), intent(in) :: x1,x2
  real(wp) :: res
  real(wp), dimension(size(x1)) :: diff 
  
  diff = x1 - x2
  res = sqrt( sum(diff**2)/size(diff) )
end function rmse

function mae(x1,x2) result(res)
  implicit none 
  real(wp), dimension(:), intent(in) :: x1,x2
  real(wp) :: res
  real(wp), dimension(size(x1)) :: diff 
  
  diff = abs(x1 - x2)
  res = sum(diff, dim=1)/size(diff, dim=1)
end function mae

function bias(x1,x2) result(res)
  implicit none 
  real(wp), dimension(:), intent(in) :: x1,x2
  real(wp) :: mean1,mean2, res
  
  mean1 = sum(x1, dim=1)/size(x1, dim=1)
  mean2 = sum(x2, dim=1)/size(x2, dim=1)
  res = mean1 - mean2

end function bias

function mean(x) result(mean1)
  implicit none 
  real(wp), dimension(:), intent(in) :: x
  real(wp) :: mean1
  mean1 = sum(x) / size(x)
end function mean

function mean_2d(x) result(mean2)
  implicit none 
  real(wp), dimension(:,:), intent(in) :: x
  real(wp) :: mean2
  mean2 = sum(x) / size(x)
end function mean_2d

function mean_3d(x) result(mean3)
  implicit none 
  real(wp), dimension(:,:,:), intent(in) :: x
  real(wp) :: mean3
  mean3 = sum(x) / size(x)
end function mean_3d

end program
